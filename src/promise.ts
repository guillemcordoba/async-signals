import { Signal } from "signal-polyfill";
import { AsyncSignal, AsyncState } from "./async-signals.js";

// NOTE: This scheduling logic is too basic to be useful. Do not copy/paste.
// This function would usually live in a library/framework, not application code
let pending = false;

let w = new Signal.subtle.Watcher(() => {
  if (!pending) {
    pending = true;
    queueMicrotask(() => {
      pending = false;
      for (let s of w.getPending()) s.get();
      w.watch();
    });
  }
});

// TODO: why do we need to use this complicated effect method?
// An effect effect Signal which evaluates to cb, which schedules a read of
// itself on the microtask queue whenever one of its dependencies might change
function effect(cb) {
  let destructor;
  let c = new Signal.Computed(() => {
    destructor?.();
    destructor = cb();
  });
  w.watch(c);
  c.get();
  return () => {
    destructor?.();
    w.unwatch(c);
  };
}

/**
 * Waits for the signal to completes its task and returns its value
 *
 * Note that it will only return the first "completed" value generated by the signal,
 * and will unsubscribe after that
 */
export function toPromise<T, E = unknown>(
  asyncSignal: AsyncSignal<T, E>,
): Promise<T> {
  return new Promise((resolve, reject) => {
    // If the signal is not pending, return immediately
    const result = asyncSignal.get();
    if (result.status === "completed") {
      resolve(result.value);
      return;
    } else if (result.status === "error") {
      reject(result.error);
      return;
    }

    const unsubs = effect(() => {
      const result = asyncSignal.get();
      if (result.status === "pending") return;
      else if (result.status === "completed") {
        resolve(result.value);
        unsubs();
      } else if (result.status === "error") {
        reject(result.error);
        unsubs();
      }
    });
  });
}

/**
 * Converts a task that returns a promise into an `AsyncSignal`
 *
 * Useful for tasks whose result doesn't need to be updated after they resolve
 */
export function fromPromise<T>(task: () => Promise<T>): AsyncSignal<T> {
  const signal = new AsyncState<T>(
    { status: "pending" },
    {
      [Signal.subtle.watched]: () => {
        task()
          .then((value) => {
            signal.set({
              status: "completed",
              value,
            });
          })
          .catch((error) => {
            signal.set({
              status: "error",
              error,
            });
          });
      },
      [Signal.subtle.unwatched]: () => {
        // We revert back to pending state so that the next time this signal is queried,
        // the backend request is sent again
        setTimeout(() => {
          signal.set({
            status: "pending",
          });
        });
      },
    },
  );
  return signal;
}
